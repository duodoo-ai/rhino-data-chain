# -*- coding: utf-8 -*-
import logging

from odoo import api, fields, models
from odoo.exceptions import UserError
from odoo.tools import float_compare

_logger = logging.getLogger(__name__)


class ResPartner(models.Model):
    _inherit = 'res.partner'

    # contacts_ids = fields.One2many('res.partner.contacts', 'partner_id', string='收货信息')


class SaleOrderLine(models.Model):
    _inherit = 'sale.order.line'

    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
        """
        Launch procurement group run method with required/custom fields generated by a
        sale order line. procurement group will launch '_run_pull', '_run_buy' or '_run_manufacture'
        depending on the sale order line product rule.
        """
        if self._context.get("skip_procurement"):
            return True
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        procurements = []
        for line in self:
            line = line.with_company(line.company_id)
            if line.state != 'sale' or not line.product_id.type in ('cons', 'product'):
                continue
            qty = line._get_qty_procurement(previous_product_uom_qty)
            if float_compare(qty, line.product_uom_qty, precision_digits=precision) == 0:
                continue

            group_id = line._get_procurement_group()
            if not group_id:
                group_id = self.env['procurement.group'].create(line._prepare_procurement_group_vals())
                line.order_id.procurement_group_id = group_id
            else:
                # In case the procurement group is already created and the order was
                # cancelled, we need to update certain values of the group.
                updated_vals = {}
                if group_id.partner_id != line.order_id.partner_shipping_id:
                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})
                if group_id.move_type != line.order_id.picking_policy:
                    updated_vals.update({'move_type': line.order_id.picking_policy})
                if updated_vals:
                    group_id.write(updated_vals)

            values = line._prepare_procurement_values(group_id=group_id)
            values.update({'sale_order_name':line.order_id.name})
            product_qty = line.product_uom_qty - qty

            line_uom = line.product_uom
            quant_uom = line.product_id.uom_id
            location_id = self.env.ref('stock.stock_location_stock')
            product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
            virtual_available = line.product_id.with_context(location=False).virtual_available  # 在制品数量

            partner_make_qty = sum(self.env['mrp.production'].search(
                [
                    ('state', 'not in', ('done', 'cancel')), ('product_id', '=', line.product_id.id),
                 ('partner_id', '=', line.order_partner_id.id),('sale_order_name','=',line.order_id.name)
                 ])
            .mapped(
                'product_qty')) or 0
            other_make_qty = sum(self.env['mrp.production'].search(
                [
                    ('state', 'not in', ('done', 'cancel')), ('product_id', '=', line.product_id.id),
                 ('partner_id', '=', False),('sale_order_name','=',False)
                 ])
            .mapped(
                'product_qty'))
            sale_available = sum(self.env['sale.order.line'].search([
                ('order_id.state', '!=', 'cancel'),
                ('product_id', '=', line.product_id.id)]).mapped('product_uom_qty')) or 0

            make_qty = partner_make_qty+other_make_qty

            if make_qty <= 0:
                production_qty = product_qty
            elif (make_qty) < product_qty:
                if (sale_available - virtual_available) >= product_qty:
                    production_qty = product_qty
                else:
                    production_qty = sale_available - virtual_available
                # production_qty = product_qty - (make_qty)
            else:
                continue
            procurements.append(self.env['procurement.group'].Procurement(
                line.product_id, production_qty, procurement_uom,
                location_id,
                line.product_id.display_name, line.order_id.name, line.order_id.company_id, values))

        if procurements:
            # print(procurements)
            self.env['procurement.group'].with_context(auto_mto=True,pid=values.get('partner_id'),sid=values.get('sale_order_name')
                                                       ).run(procurements)

        # This next block is currently needed only because the scheduler trigger is done by picking confirmation rather than stock.move confirmation
        orders = self.mapped('order_id')
        for order in orders:
            pickings_to_confirm = order.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
            if pickings_to_confirm:
                # Trigger the Scheduler for Pickings
                pickings_to_confirm.action_confirm()
        return True


class SaleOrder(models.Model):
    _inherit = "sale.order"

    delivery_ids = fields.One2many('sale.delivery', 'sale_id', string='发货通知单')
    is_delivery = fields.Boolean('启用发货通知', default=True)

    @api.depends('name')
    def name_get(self):
        result = []
        for event in self:
            partner = event.partner_id or False
            if partner:
                name = partner.name and partner.name + " - " or ""
                name += event.name and event.name or ""
                result.append((event.id, name))
            else:
                name += event.name and event.name or ""
                result.append((event.id, name))
        return result

    # 改写原来销售订单确认
    def _action_confirm(self):
        for order in self:
            order.order_line._action_launch_stock_rule()
            if order.is_delivery:
                sale_delivery = self.env['sale.delivery'].search([('sale_id', '=', order.id)])
                # 最开始已经调用了，不注释会产生两次生产单
                order.order_line._action_launch_stock_rule()
                if not sale_delivery:
                    partner_id = order.partner_id
                    delivery_address = (partner_id.state_id.name or '') + (partner_id.city or '') + (
                            partner_id.street or '') + (partner_id.street2 or '')
                    sale_delivery = self.env['sale.delivery'].sudo().create({
                        'sale_id': order.id,
                        'user_id': order.user_id.id,
                        'delivery_address': delivery_address
                    })
                    for line in order.order_line:
                        if line.product_id:
                            vals = {
                                'order_id': sale_delivery.id,
                                'sale_line_id': line.id,
                                'delivery_qty': line.product_uom_qty - line.qty_delivered
                            }
                            self.env['sale.delivery.line'].create(vals)
                else:
                    raise UserError(("已存在发货通知单%s，请查看！" % sale_delivery.name))
            res = super(SaleOrder, order)._action_confirm()
            return res


        # super(SaleOrder, self-lines)._action_confirm()

    def action_cancel(self):
        for delivery in self.delivery_ids:
            delivery.unlink()
        return super(SaleOrder, self).action_cancel()
